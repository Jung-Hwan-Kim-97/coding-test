// 1. 선택 정렬

// N개이 숫자가 입력되면 오름차순으로 정렬하여 출력하는 프로그램을 작성하세요. 정렬하는 방법은 선택정렬입니다.

// ▣ 입력설명
// 첫 번째 줄에 자연수 N(1<=N<=100)이 주어집니다. 두 번째 줄에 N개의 자연수가 공백을 사이에 두고 입력됩니다. 각 자연수는 정수형 범위 안에있습니다.

// ▣ 출력설명
// 오름차순으로 정렬된 수열을 출력합니다.

// ▣ 입력예제 1
// 13 5 11 7 23 15

// ▣ 출력예제 1
// 5 7 11 13 15 23

// const solution = (arr) => {
//   let answer;
//   const n = arr.length;
//   for (let i = 0; i < n; i++) {
//     let index = i;
//     for (let j = i + 1; j < n; j++) {
//       if (arr[index] > arr[j]) index = j;
//     }
//     [arr[i], arr[index]] = [arr[index], arr[i]];
//   }
//   answer = arr;

//   return answer;
// };

// console.log(solution([13, 5, 11, 7, 23, 15]));

//2 버블 정렬
// N개이 숫자가 입력되면 오름차순으로 정렬하여 출력하는 프로그램을 작성하세요.정렬하는 방법은 버블정렬입니다.

// ▣ 입력설명
// 첫 번째 줄에 자연수 N(1<=N<=100)이 주어집니다. 두 번째 줄에 N개의 자연수가 공백을 사이에 두고 입력됩니다. 각 자연수는 정수형 범위 안에있습니다.

// ▣ 출력설명
// 오름차순으로 정렬된 수열을 출력합니다.

// ▣ 입력예제 1
// 13 5 11 7 23 15

// ▣ 출력예제 1
// 5 7 11 13 15 23

// const solution = (arr) => {
//   let answer;
//   const n = arr.length;
//   for (let i = 0; i < n; i++) {
//     for (let j = 0; j < n; j++) {
//       if (arr[j] > arr[j + 1]) {
//         [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
//       }
//     }
//   }

//   answer = arr;
//   return answer;
// };

// console.log(solution([13, 5, 11, 7, 23, 15]));

//3.Special Sort(구글 인터뷰)

// N개의 정수가 입력되면 당신은 입력된 값을 정렬해야 한다. 음의 정수는 앞쪽에 양의정수는 뒷쪽에 있어야 한다. 또한 양의정수와 음의정수의 순서에는 변함이 없어야 한다.

// ▣ 입력설명
// 첫 번째 줄에 정수 N(5<=N<=100)이 주어지고, 그 다음 줄부터 음수를 포함한 정수가 주어진다. 숫자 0은 입력되지 않는다.
// ▣ 출력설명
// 정렬된 결과를 출력한다.

// ▣ 입력예제 1
// 8
// 1 2 3 -3 -2 5 6 -6

// ▣ 출력예제 1
// -3 -2 -6 1 2 3 5 6

// const solution = (arr) => {
//   let answer;
//   const n = arr.length;

//   for (let i = 0; i < n; i++) {
//     for (let j = 0; j < n; j++) {
//       if (arr[j] > 0 && arr[j + 1] < 0) {
//         [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
//       }
//     }
//   }

//   return answer;
// };

// console.log(solution([1, 2, 3, -3, -2, 5, 6, -6]));

//8 회의실 배정

// 한 개의 회의실이 있는데 이를 사용하고자 하는 n개의 회의들에 대하여 회의실 사용표를 만들려고 한다.

// 각 회의에 대해 시작시간과 끝나는 시간이 주어져 있고, 각 회의가 겹치지 않게 하면서 회의실을 사용할 수 있는 최대수의 회의를 찾아라. 단, 회의는 한번 시작하면 중간에 중단될 수 없으며 한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다.

// ▣ 입력설명
// 첫째 줄에 회의의 수 n(1<=n<=100,000)이 주어진다. 둘째 줄부터 n+1 줄까지 각 회의의 정보가 주어지는데 이것은 공백을 사이에 두고 회의의 시작시간과 끝나는 시간이 주어진다.
// 회의의 시작시간과 끝나는 시간의 조건은 (시작시간 <= 끝나는 시간)입니다.

// ▣ 출력설명
// 첫째 줄에 최대 사용할 수 있는 회의 수를 출력하여라.

// ▣ 입력예제 1
// 5
// 1 4
// 2 3
// 3 5
// 4 6
// 5 7

// ▣ 출력예제 1
// 3

// 예제설명
// (2, 3), (3, 5), (5, 7)이 회의실을 이용할 수 있다.

// ▣ 입력예제 2
// 3
// 3 3
// 1 3
// 2 3

// ▣ 출력예제 2
// 2

// const solution = (arr) => {
//   let answer;
//   const n = arr.length;

//   arr.sort((a, b) => {
//     if (a[1] === b[1]) {
//       return a[0] - b[0];
//     } else {
//       return a[1] - b[1];
//     }
//   });

//   let endTime = 0;
//   let count = 0;

//   for (let i = 0; i < n; i++) {
//     if (arr[i][0] >= endTime) {
//       endTime = arr[i][1];
//       count++;
//     }
//   }
//   answer = count;

//   return answer;
// };
// const grid = [
//   [1, 4],
//   [2, 3],
//   [3, 5],
//   [4, 6],
//   [5, 7],
// ];

// console.log(solution(grid));

// 9.결혼식

// 현수는 다음 달에 결혼을 합니다. 현수는 결혼식 피로연을 장소를 빌려 3일간 쉬지 않고 하려고 합니다.
// 피로연에 참석하는 친구들 N명의 참석하는 시간정보를 현수는 친구들에게 미리 요구했습니다. 각 친구들은 자신이 몇 시에 도착해서 몇 시에 떠날 것인지 현수에게 알려주었습니다.
// 현수는 이 정보를 바탕으로 피로연 장소에 동시에 존재하는 최대 인원수를 구하여 그 인원을 수용할 수 있는 장소를 빌리려고 합니다. 여러분이 현수를 도와주세요.
// 만약 한 친구가 오는 시간 13, 가는시간 15라면 이 친구는 13시 정각에 피로연 장에 존재하는 것이고 15시 정각에는 존재하지 않는다고 가정합니다.

// ▣ 입력설명
// 첫째 줄에 피로연에 참석할 인원수 N(5<=N<=100,000)이 주어집니다. 두 번째 줄부터 N줄에 걸쳐 각 인원의 오는 시간과 가는 시간이 주어집니다.
// 시간은 첫날 0시를 0으로 해서 마지막날 밤 12시를 72로 하는 타임라인으로 오는 시간과 가는 시간이 음이 아닌 정수로 표현됩니다.
// ▣ 출력설명
// 첫째 줄에 피로연장에 동시에 존재하는 최대 인원을 출력하세요.
// ▣ 입력예제 1
// 5
// 14 18
// 12 15
// 15 20
// 20 30
// 5 14
// ▣ 출력예제 1
// 2

// const solution = (grid) => {
//   let answer = 0;
//   const n = grid.length;
//   let newGrid = [];

//   for (let i = 0; i < n; i++) {
//     newGrid.push([grid[i][0], "s"]);
//     newGrid.push([grid[i][1], "e"]);
//   }

//   newGrid.sort((a, b) => {
//     if (a[0] === b[0]) return a[1].charCodeAt() - b[1].charCodeAt();
//     else return a[0] - b[0];
//   });
//   let count = 0;

//   for (let i = 0; i < newGrid.length; i++) {
//     if (newGrid[i][1] === "s") count++;
//     else count--;

//     answer = Math.max(answer, count);
//   }

//   return answer;
// };

// const grid = [
//   [14, 18],
//   [12, 15],
//   [15, 20],
//   [20, 30],
//   [5, 14],
// ];
// console.log(solution(grid));

//10. 이분검색

// 임의의 N개의 숫자가 입력으로 주어집니다. N개의 수를 오름차순으로 정렬한 다음 N개의 수중 한 개의 수인 M이 주어지면 이분검색으로 M이 정렬된 상태에서 몇 번째에 있는지 구하는프로그램을 작성하세요.
// 단 중복값은 존재하지 않습니다.

// ▣ 입력설명
// 첫 줄에 한 줄에 자연수 N(3<=N<=1,000,000)과 M이 주어집니다.두 번째 줄에 N개의 수가 공백을 사이에 두고 주어집니다.

// ▣ 출력설명
// 첫 줄에 정렬 후 M의 값의 위치 번호를 출력한다.

// ▣ 입력예제 1
// 8 32
// 23 87 65 12 57 32 99 81

// ▣ 출력예제 1
// 3

// const solution = (arr, m) => {
//   let answer;
//   arr.sort((a, b) => a - b);
//   let lt = 0;
//   let rt = arr.length - 1;

//   while (lt <= rt) {
//     let mid = Math.floor((lt + rt) / 2);
//     if (arr[mid] === m) {
//       answer = mid + 1;
//       break;
//     } else if (arr[mid] > m) rt = mid - 1;
//     else lt = mid + 1;
//   }

//   return answer;
// };
// const arr = [23, 87, 65, 12, 57, 32, 99, 81];
// const m = 32;

// console.log(solution(arr, m));

//11. 뮤직비디오(결정알고리즘)
// 지니레코드에서는 불세출의 가수 조영필의 라이브 동영상을 DVD로 만들어 판매하려 한다.
// DVD에는 총 N개의 곡이 들어가는데, DVD에 녹화할 때에는 라이브에서의 순서가 그대로 유지되어야 한다.
// 순서가 바뀌는 것을 우리의 가수 조영필씨가 매우 싫어한다. 즉, 1번 노래와 5번 노래를 같은 DVD에 녹화하기 위해서는 1번과 5번 사이의 모든 노래도 같은 DVD에 녹화해야한다.

// 또한 한 노래를 쪼개서 두 개의 DVD에 녹화하면 안된다.지니레코드 입장에서는 이 DVD가 팔릴 것인지 확신할 수 없기 때문에 이 사업에 낭비되는DVD를 가급적 줄이려고 한다.

// 고민 끝에 지니레코드는 M개의 DVD에 모든 동영상을 녹화하기로 하였다. 이 때 DVD의 크기(녹화 가능한 길이)를 최소로 하려고 한다. 그리고 M개의 DVD는모두 같은 크기여야 제조원가가 적게 들기 때문에 꼭 같은 크기로 해야 한다.

// ▣ 입력설명
// 첫째 줄에 자연수 N(1≤N≤1,000), M(1≤M≤N)이 주어진다. 다음 줄에는 조영필이 라이브에서부른 순서대로 부른 곡의 길이가 분 단위로(자연수) 주어진다. 부른 곡의 길이는 10,000분을 넘지 않는다고 가정하자.

// ▣ 출력설명
// 첫 번째 줄부터 DVD의 최소 용량 크기를 출력하세요.

// ▣ 입력예제 1
// 9 3
// 1 2 3 4 5 6 7 8 9

// ▣ 출력예제 1
// 17

// 다시 풀어야함
// const solution = (songs) => {
//   let answer;

//   let lp = Math.max(...songs);
//   let rp = songs.reduce((acc, cur) => acc + cur, 0);

//   let mid = Math.floor((lp + rp) / 2);

//   return answer;
// };

// const songs = [1, 2, 3, 4, 5, 6, 7, 8, 9];

// console.log(solution(songs));
